{"meta":{"title":"ZhangYutong","subtitle":"君子性非异也, 善假于物也","description":"有趣的博客","author":"ZhangYutong","url":"https://interestingblog.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-02-13T02:56:34.491Z","updated":"2022-02-13T02:56:34.491Z","comments":false,"path":"/404.html","permalink":"https://interestingblog.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-02-13T02:56:34.494Z","updated":"2022-02-13T02:56:34.494Z","comments":false,"path":"about/index.html","permalink":"https://interestingblog.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-02-13T02:56:34.494Z","updated":"2022-02-13T02:56:34.494Z","comments":false,"path":"books/index.html","permalink":"https://interestingblog.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-13T02:56:34.496Z","updated":"2022-02-13T02:56:34.496Z","comments":true,"path":"links/index.html","permalink":"https://interestingblog.top/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-13T02:56:34.495Z","updated":"2022-02-13T02:56:34.495Z","comments":false,"path":"categories/index.html","permalink":"https://interestingblog.top/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-13T02:56:34.497Z","updated":"2022-02-13T02:56:34.497Z","comments":false,"path":"repository/index.html","permalink":"https://interestingblog.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-13T02:56:34.498Z","updated":"2022-02-13T02:56:34.498Z","comments":false,"path":"tags/index.html","permalink":"https://interestingblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode539.复数乘法","slug":"leetcode539","date":"2022-02-25T13:09:58.000Z","updated":"2022-02-25T13:10:34.385Z","comments":true,"path":"2022/02/25/leetcode539/","link":"","permalink":"https://interestingblog.top/2022/02/25/leetcode539/","excerpt":"","text":"537. 复数乘法难度中等 118 收藏分享切换为英文接收动态反馈 复数 可以用字符串表示，遵循 &quot;实部+虚部i&quot; 的形式，并满足下述条件： 实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。 示例 1： 123输入： num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;输出： &quot;0+2i&quot;解释： (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。 示例 2： 123输入： num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;输出： &quot;0+-2i&quot;解释： (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 提示： num1 和 num2 都是有效的复数表示。 思路: 直接根据乘法乘就行了, (a + bi) * (c + di) &#x3D; ac - bd + (ad + bc)i 123456789101112131415161718192021222324252627282930313233343536// 我的代码略草, 下面是官方解class Solution &#123; public String complexNumberMultiply(String num1, String num2) &#123; String[] num1Split = num1.split(&quot;\\\\+&quot;); String[] num2Split = num2.split(&quot;\\\\+&quot;); int num1IntLeft = Integer.parseInt(num1Split[0]); int num2IntLeft = Integer.parseInt(num2Split[0]); int totalLeft = num1IntLeft * num2IntLeft; int num1IntRight = Integer.parseInt(num1Split[1].replace(&quot;i&quot;, &quot;&quot;)); int num2IntRight = Integer.parseInt(num2Split[1].replace(&quot;i&quot;, &quot;&quot;)); int totalRight = num1IntRight * num2IntRight * -1; int totalNum = totalLeft + totalRight; int iLeft = num1IntLeft * num2IntRight; int iRight = num1IntRight * num2IntLeft; int totalI = iLeft + iRight; return totalNum + &quot;+&quot; + totalI + &quot;i&quot;; &#125;&#125;/**作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/complex-number-multiplication/solution/fu-shu-cheng-fa-by-leetcode-solution-163i/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。*/class Solution &#123; public String complexNumberMultiply(String num1, String num2) &#123; String[] complex1 = num1.split(&quot;\\\\+|i&quot;); String[] complex2 = num2.split(&quot;\\\\+|i&quot;); int real1 = Integer.parseInt(complex1[0]); int imag1 = Integer.parseInt(complex1[1]); int real2 = Integer.parseInt(complex2[0]); int imag2 = Integer.parseInt(complex2[1]); return String.format(&quot;%d+%di&quot;, real1 * real2 - imag1 * imag2, real1 * imag2 + imag1 * real2); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode917.仅仅反转字母","slug":"leetcode917","date":"2022-02-23T12:38:06.000Z","updated":"2022-02-25T13:10:53.749Z","comments":true,"path":"2022/02/23/leetcode917/","link":"","permalink":"https://interestingblog.top/2022/02/23/leetcode917/","excerpt":"","text":"原题地址:https://leetcode-cn.com/problems/reverse-only-letters/ 思路: 双指针, 可以先将特殊字符放到新的数组, 然后遍历, 依次将空白填上即可. 12345678910111213141516171819202122class Solution &#123; public String reverseOnlyLetters(String s) &#123; char[] result = new char[s.length()]; char[] charArray = s.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) &#123; if (charArray[i] &lt; 65 || (charArray[i] &gt; 90 &amp;&amp; charArray[i] &lt; 97) || charArray[i] &gt; 122) &#123; result[i] = charArray[i]; &#125; &#125; int i = 0, j = charArray.length - 1; while (i &lt; charArray.length) &#123; if (result[i] != &#x27;\\u0000&#x27;) &#123; i++; &#125; else if (charArray[j] &lt; 65 || (charArray[j] &gt; 90 &amp;&amp; charArray[j] &lt; 97) || charArray[j] &gt; 122) &#123; j--; &#125; else &#123; result[i++] = charArray[j--]; &#125; &#125; return new String(result); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://interestingblog.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode剑指Offer09.用两个栈实现队列","slug":"leetcode-jz09","date":"2022-02-21T13:17:12.000Z","updated":"2022-02-21T13:17:56.298Z","comments":true,"path":"2022/02/21/leetcode-jz09/","link":"","permalink":"https://interestingblog.top/2022/02/21/leetcode-jz09/","excerpt":"","text":"原题地址: https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/ 思路: 使用两个栈模拟队列, 一个 in, 一个 out, 当入队时向 in push, 出队时判断 out 是否为空, 如果为空将 in 栈所有数据 pop 并 push 到 out 栈, 然后返回 out.pop. 1234567891011121314151617181920212223242526272829303132class CQueue &#123; private Stack&lt;Integer&gt; in; private Stack&lt;Integer&gt; out; public CQueue() &#123; in = new Stack&lt;&gt;(); out = new Stack&lt;&gt;(); &#125; public void appendTail(int value) &#123; in.push(value); &#125; public int deleteHead() &#123; if (out.empty()) &#123; while (!in.empty()) &#123; out.push(in.pop()); &#125; &#125; if (out.empty()) &#123; return -1; &#125; return out.pop(); &#125;&#125;/** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273type CQueue struct &#123; Out Stack In Stack&#125;func Constructor() CQueue &#123; return CQueue&#123; Out: NewStack(), In: NewStack(), &#125;&#125;func (c *CQueue) AppendTail(value int) &#123; c.In.Push(value)&#125;func (c *CQueue) DeleteHead() int &#123; if !c.Out.Empty() &#123; return c.Out.Pop() &#125; else &#123; for !c.In.Empty() &#123; c.Out.Push(c.In.Pop()) &#125; &#125; return c.Out.Pop()&#125;// Stack 栈type Stack struct &#123; Values []int&#125;// NewStack 栈 构造函数func NewStack() Stack &#123; return Stack&#123;Values: make([]int, 0, 5)&#125;&#125;// Push 进func (s *Stack) Push(val int) &#123; s.Values = append(s.Values, val)&#125;// Pop 出func (s *Stack) Pop() int &#123; values := s.Values if s.Empty() &#123; return -1 &#125; length := len(values) result := values[length-1] s.Values = values[:length-1] return result&#125;func (s *Stack) Peek() int &#123; if s.Empty() &#123; return -1 &#125; return s.Values[len(s.Values)-1]&#125;func (s *Stack) Empty() bool &#123; return s.Values == nil || len(s.Values) == 0&#125;/** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.DeleteHead(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://interestingblog.top/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://interestingblog.top/tags/%E6%A0%88/"}]},{"title":"LeetCode281周赛6014.构造限制重复的字符串","slug":"leetcode6014","date":"2022-02-20T11:49:22.000Z","updated":"2022-02-20T11:49:49.451Z","comments":true,"path":"2022/02/20/leetcode6014/","link":"","permalink":"https://interestingblog.top/2022/02/20/leetcode6014/","excerpt":"","text":"原题地址: https://leetcode-cn.com/problems/construct-string-with-repeat-limit/ 思路: 贪心, 构造 map 存储遍历次数, 每次取最大的字母, 遍历不超过 repeatLimit 次, 若有剩余则再取一次除当前字母外最大字母, 依次追加 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String repeatLimitedString(String s, int repeatLimit) &#123; int[] map = new int[26]; // 构造map for (int i = 0; i &lt; s.length(); i++) &#123; map[s.charAt(i) - &#x27;a&#x27;] ++; &#125; // 结果字符串 StringBuilder stringBuilder = new StringBuilder(); // 找最大的字母 int minChar = getMinChar(map, map.length - 1); // 直到minChar获取不到值 while (minChar &gt;= 0) &#123; int count = Math.min(repeatLimit, map[minChar]); while (count -- &gt; 0) &#123; map[minChar] --; stringBuilder.append((char) (minChar + &#x27;a&#x27;)); &#125; if (minChar == 0) break; // 剩下的 if (map[minChar] != 0) &#123; int temp = minChar; minChar = getMinChar(map, minChar - 1); if (minChar &lt; 0) break; stringBuilder.append((char) (minChar + &#x27;a&#x27;)); map[minChar] --; minChar = getMinChar(map, temp); &#125; else &#123; minChar = getMinChar(map, minChar); &#125; &#125; return stringBuilder.toString(); &#125; public int getMinChar(int[] map, int minChar) &#123; for (int i = minChar; i &gt;= 0; i--) &#123; if (map[i] != 0) return i; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"周赛","slug":"周赛","permalink":"https://interestingblog.top/tags/%E5%91%A8%E8%B5%9B/"},{"name":"贪心","slug":"贪心","permalink":"https://interestingblog.top/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"LeetCode281周赛6013.合并零之间的节点","slug":"leetcode6013","date":"2022-02-20T06:42:21.000Z","updated":"2022-02-20T07:44:06.720Z","comments":true,"path":"2022/02/20/leetcode6013/","link":"","permalink":"https://interestingblog.top/2022/02/20/leetcode6013/","excerpt":"","text":"原题地址: https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/ 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeNodes(ListNode head) &#123; ListNode temp = head, last = head.next; // 原地修改, 双指针 int val = 0; while (last != null) &#123; if (last.val == 0) &#123; // 移动到下一个0处时, 给temp赋值并指向下一个0 temp.val = val; val = 0; if (last.next == null) &#123; temp.next = null; &#125; else &#123; temp.next = last; temp = temp.next; &#125; &#125; val += last.val; last = last.next; &#125; return head; &#125;&#125; 思路: 双指针, 左边指向 0 所在节点, 右边遍历, 当右指针指向 0 时, 将和放到左指针指向位置并改变左指针指向为右指针位置, 然后继续遍历, 重复操作至右指针指向最后一个节点.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://interestingblog.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"周赛","slug":"周赛","permalink":"https://interestingblog.top/tags/%E5%91%A8%E8%B5%9B/"},{"name":"链表","slug":"链表","permalink":"https://interestingblog.top/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"LeetCode281周赛6012.统计各位数字之和为偶数的整数个数","slug":"leetcode6012","date":"2022-02-20T06:27:05.000Z","updated":"2022-02-20T06:37:32.559Z","comments":true,"path":"2022/02/20/leetcode6012/","link":"","permalink":"https://interestingblog.top/2022/02/20/leetcode6012/","excerpt":"","text":"原题地址: https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/ 123456789101112131415161718class Solution &#123; public int countEven(int num) &#123; int count = 0, index = 2; while (index &lt;= num) &#123; int temp = index; int i = 0; while (temp != 0) &#123; i += temp % 10; temp = temp / 10; &#125; if (i % 2 == 0) &#123; count ++; &#125; index ++; &#125; return count; &#125;&#125; 思路: 遍历直接从 2 开始, 对每一位数相加判断即可","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"遍历","slug":"遍历","permalink":"https://interestingblog.top/tags/%E9%81%8D%E5%8E%86/"},{"name":"周赛","slug":"周赛","permalink":"https://interestingblog.top/tags/%E5%91%A8%E8%B5%9B/"}]},{"title":"LeetCode717.1比特与2比特字符","slug":"leetcode717","date":"2022-02-20T06:23:41.000Z","updated":"2022-02-20T06:25:19.530Z","comments":true,"path":"2022/02/20/leetcode717/","link":"","permalink":"https://interestingblog.top/2022/02/20/leetcode717/","excerpt":"","text":"12345678910class Solution &#123; public boolean isOneBitCharacter(int[] bits) &#123; int n = bits.length - 1, i = 0; while (i &lt; n) &#123; if (bits[i] == 0) i+=1; else i += 2; &#125; return n == i; &#125;&#125; 思路: 遍历, 0 开头的走一位, 1 开头的走两位(不管是 11 还是 10 都是两位), 走到最后判断是不是最后一位的下标即可","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"遍历","slug":"遍历","permalink":"https://interestingblog.top/tags/%E9%81%8D%E5%8E%86/"}]},{"title":"LeetCode969. 煎饼排序","slug":"leetcode969","date":"2022-02-19T06:16:34.000Z","updated":"2022-02-19T06:17:48.592Z","comments":true,"path":"2022/02/19/leetcode969/","link":"","permalink":"https://interestingblog.top/2022/02/19/leetcode969/","excerpt":"","text":"leetcode 地址: https://leetcode-cn.com/problems/pancake-sorting/ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; boolean isSorted(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; if (array[i] &gt; array[i + 1]) return false; &#125; return true; &#125; public List&lt;Integer&gt; pancakeSort(int[] arr) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int length = arr.length; for (int i = length - 1; i &gt;= 0; i--) &#123; if (isSorted(arr)) return result; int maxIndex = 0; // 先找最大值 for (int j = 0; j &lt;= i; j++) &#123; if (arr[maxIndex] &lt; arr[j]) &#123; maxIndex = j; &#125; &#125; // 翻转0-maxIndex reverse(arr, 0, maxIndex); result.add(maxIndex + 1); // 翻转0-i reverse(arr, 0, i); result.add(i + 1); &#125; return result; &#125; public void reverse(int[] arr, int i, int j) &#123; while (i &lt; j) &#123; int temp = arr[i]; arr[i++] = arr[j]; arr[j--] = temp; &#125; &#125;&#125; 思路: 煎饼排序简单解释就是对于数组的某一段进行翻转, 使逐渐排好序. 根据这个特性, 可以使用冒泡排序的思维, 先从后开始循环 n 次(数组长度), 每次找到最大的值, 然后翻转到指针指向位, 逐步排好序即可 官方[3,2,4,1] &#x3D;&gt; 可为[3, 4, 2, 3, 1, 2] 如图:","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://interestingblog.top/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"}]},{"title":"LeetCode1791. 找出星型图的中心节点","slug":"leetcode1791","date":"2022-02-18T12:23:15.000Z","updated":"2022-02-18T12:23:53.715Z","comments":true,"path":"2022/02/18/leetcode1791/","link":"","permalink":"https://interestingblog.top/2022/02/18/leetcode1791/","excerpt":"","text":"leetcode 地址: https://leetcode-cn.com/problems/find-center-of-star-graph/ 思路: 中心结点连接所有节点, 因此会出现在每一个数组中, 因此找到重复元素即可 1234567class Solution &#123; public int findCenter(int[][] edges) &#123; int[] edge = edges[0]; if (edges[1][0] == edge[0]||edges[1][0] == edge[1]) return edges[1][0]; else return edges[1][1]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode688. 骑士在棋盘上的概率","slug":"leetcode688","date":"2022-02-17T14:44:40.000Z","updated":"2022-02-20T08:19:25.451Z","comments":true,"path":"2022/02/17/leetcode688/","link":"","permalink":"https://interestingblog.top/2022/02/17/leetcode688/","excerpt":"","text":"leetcode 地址: https://leetcode-cn.com/problems/knight-probability-in-chessboard/ 思路 1: 记忆化搜索 123456789101112131415161718192021222324252627public class Solution &#123; // 移动轨迹 private static final int[][] dirs = &#123; &#123; 1, 2 &#125;, &#123; 2, 1 &#125;, &#123; -1, 2 &#125;, &#123; 2, -1 &#125;, &#123; 1, -2 &#125;, -2, 1 &#125;, &#123; -1, -2 &#125;, &#123; -2, -1 &#125; &#125;; public double knightProbability(int n, int k, int row, int column) &#123; double[][][] memo = new double[n][n][k + 1]; return dfs(n, k, row, column, memo); &#125; public double dfs(int n, int k, int row, int column, double[][][] memo) &#123; if (row &lt; 0 || column &lt; 0 || row &gt;= n || column &gt;= n) &#123; return 0; &#125; if (k == 0) &#123; return 1; &#125; if (memo[row][column][k] != 0) &#123; return memo[row][column][k]; &#125; double ans = 0; for (int i = 0; i &lt; dirs.length; i++) &#123; ans += dfs(n, k - 1, row + dirs[i][0], column + dirs[i][1], memo) / 8.0; &#125; memo[row][column][k] = ans; return ans; &#125;&#125; 思路 2: 动态规划 12345678910111213141516171819202122232425262728public class Solution &#123; private static final int[][] dirs = &#123; &#123; 1, 2 &#125;, &#123; 2, 1 &#125;, &#123; -1, 2 &#125;, &#123; 2, -1 &#125;, &#123; 1, -2 &#125;, &#123; -2, 1 &#125;, &#123; -1, -2 &#125;, &#123; -2, -1 &#125; &#125;; public double knightProbability(int n, int k, int row, int column) &#123; double[][][] dp = new double[n][n][k + 1]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dp[i][j][0] = 1; &#125; &#125; // 从0起 for (int kk = 1; kk &lt;= k; kk++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int[] dir : dirs) &#123; int nx = dir[0] + i; int ny = dir[1] + j; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) dp[i][j][kk] += dp[nx][ny][kk - 1] / 8.0; &#125; &#125; &#125; &#125; return dp[row][column][k]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://interestingblog.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://interestingblog.top/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"LeetCode26. 删除有序数组中的重复项","slug":"leetcode26","date":"2022-02-16T13:11:25.000Z","updated":"2022-02-17T14:45:53.554Z","comments":true,"path":"2022/02/16/leetcode26/","link":"","permalink":"https://interestingblog.top/2022/02/16/leetcode26/","excerpt":"","text":"leetcode 地址: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 思路: 双指针, 左指针移动到比对位置, 右指针移动到下一个不同数字处替换左指针的下一位, 时间复杂度 O(n), 空间复杂度 O(1) 1234567891011121314class Solution &#123; public int removeDuplicates(int[] nums) &#123; int m = 0, n = 0; // 左指针移动到被替换位置, 右指针移动到下一个不同数字处 while (n &lt; nums.length) &#123; if (nums[m] != nums[n]) &#123; // 左指针移动一位后替换 nums[++ m] = nums[n]; &#125; n ++; &#125; return m + 1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://interestingblog.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode每日一题1380. 矩阵中的幸运数","slug":"leetcode1380","date":"2022-02-15T13:00:12.000Z","updated":"2022-02-17T14:46:49.653Z","comments":true,"path":"2022/02/15/leetcode1380/","link":"","permalink":"https://interestingblog.top/2022/02/15/leetcode1380/","excerpt":"","text":"思路: 同行最小且同列最大的数只有一个, 找到每行最小的数, 每列最大的数, 然后遍历找相同的数即可 1234567891011121314151617181920212223class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int[] row = new int[m]; int[] col = new int[n]; // 给行最小值数组填充值 Arrays.fill(row,Integer.MAX_VALUE); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; row[i] = Math.min(matrix[i][j], row[i]); col[j] = Math.max(matrix[i][j], col[j]); &#125; &#125; for (int i = 0; i &lt; row.length; i++) &#123; for (int j = 0; j &lt; col.length; j++) &#123; if (row[i] == col[j]) res.add(row[i]); &#125; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode每日一题540. 有序数组中的单一元素","slug":"leetcode540","date":"2022-02-14T12:19:38.000Z","updated":"2022-02-17T14:45:56.393Z","comments":true,"path":"2022/02/14/leetcode540/","link":"","permalink":"https://interestingblog.top/2022/02/14/leetcode540/","excerpt":"","text":"123456789class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int result = 0; for (int i = 0; i &lt; nums.length; i++) &#123; result ^= nums[i]; &#125; return result; &#125;&#125; 思路 1: 按位异或, 因为处了目标之外其他元素都出现了两次, 所以可以通过异或来拿到最终的值;时间复杂度 O(n) 空间复杂度 O(1)tips:0 ^ 0 &#x3D; 0; 1 ^ 1 &#x3D; 0; 0 ^ 1 &#x3D; 1; 123456789101112131415161718class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int i = 0, j = nums.length - 1; while (i &lt; j) &#123; int mid = i + ((j - i) &gt;&gt; 1); if (mid % 2 == 0) &#123; // 偶数 if (nums[mid] == nums[mid + 1]) i = mid + 1; else j = mid; &#125; else &#123; // 奇数 if (nums[mid] == nums[mid - 1]) i = mid + 1; else j = mid; &#125; &#125; return nums[i]; &#125;&#125; 思路 2: 二分法, 根据 mid 奇偶数判断相应情况 时间复杂度 O(logn) 空间复杂度 O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://interestingblog.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二分","slug":"二分","permalink":"https://interestingblog.top/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"LeetCode57.和为s的两个数字","slug":"leetcode57","date":"2022-02-13T13:32:34.000Z","updated":"2022-02-17T14:46:00.450Z","comments":true,"path":"2022/02/13/leetcode57/","link":"","permalink":"https://interestingblog.top/2022/02/13/leetcode57/","excerpt":"","text":"思路 1: hash 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int num : nums) &#123; if (map.get(target - num) != null) &#123; return new int[]&#123;num, target - num&#125;; &#125; map.put(num, num); &#125; return null; &#125;&#125; 使用 hash 存储, 跟两数之和一个解法. 思路 2: 双指针 12345678910class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int i = 0, j = nums.length - 1; while (true) &#123; if (nums[i] + nums[j] &gt; target) j--; else if (nums[i] + nums[j] &lt; target) i ++; else return new int[] &#123;nums[i], nums[j]&#125;; &#125; &#125;&#125; 双指针对撞, 大于左移右指针, 小于右移左指针, 等于则返回.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://interestingblog.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode每日一题1189. \"气球\"的最大数量","slug":"leetcode1189","date":"2022-02-13T08:06:14.000Z","updated":"2022-02-17T14:46:49.653Z","comments":true,"path":"2022/02/13/leetcode1189/","link":"","permalink":"https://interestingblog.top/2022/02/13/leetcode1189/","excerpt":"","text":"思路: hash, 将每个字符存在 hash, 最后取出最小值即可;注意: l&#x2F;o 值需要除以二, 因为需求是两个 l&#x2F;o 12345678910111213141516171819202122232425262728class Solution &#123; public int maxNumberOfBalloons(String text) &#123; int[] dict = new int[5]; for (int i = 0 ; i &lt; text.length() ; i ++) &#123; char ch = text.charAt(i); if (ch == &#x27;b&#x27;) &#123; dict[0] ++; &#125; else if (ch == &#x27;a&#x27;) &#123; dict[1] ++; &#125; else if (ch == &#x27;l&#x27;) &#123; dict[2] ++; &#125; else if (ch == &#x27;o&#x27;) &#123; dict[3] ++; &#125; else if (ch == &#x27;n&#x27;) &#123; dict[4] ++; &#125; &#125; dict[2] /= 2; dict[3] /= 2; int minIndex = 0; for (int i = 0 ; i &lt; dict.length ; i ++) &#123; if (dict[i] &lt; dict[minIndex]) &#123; minIndex = i; &#125; &#125; return dict[minIndex]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://interestingblog.top/tags/hash/"}]},{"title":"LeetCode每日一题1748. 唯一元素的和","slug":"leetcode1748","date":"2022-02-06T11:22:01.000Z","updated":"2022-02-17T14:47:06.340Z","comments":true,"path":"2022/02/06/leetcode1748/","link":"","permalink":"https://interestingblog.top/2022/02/06/leetcode1748/","excerpt":"","text":"123456789101112131415class Solution &#123; public int sumOfUnique(int[] nums) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0 ; i &lt; nums.length ; i ++) &#123; map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); &#125; int sum = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; if (entry.getValue() == 1) &#123; sum += entry.getKey(); &#125; &#125; return sum; &#125;&#125; 思路: 先将数存到 hash 里, 然后遍历值为 1 的 key 相加返回即可","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode每日一题1725. 可以形成最大正方形的矩形数目, 遍历","slug":"leetcode1725","date":"2022-02-04T06:19:05.000Z","updated":"2022-02-17T14:47:06.340Z","comments":true,"path":"2022/02/04/leetcode1725/","link":"","permalink":"https://interestingblog.top/2022/02/04/leetcode1725/","excerpt":"","text":"1234567891011121314151617class Solution &#123; public int countGoodRectangles(int[][] rectangles) &#123; int max = Math.min(rectangles[0][0], rectangles[0][1]); int total = 0; for (int[] rectangle : rectangles) &#123; int min = Math.min(rectangle[0], rectangle[1]); if (max &lt; min) &#123; max = min; total = 0; &#125; if (max == min)&#123; total ++; &#125; &#125; return total; &#125;&#125; 思路: 查询每个数组里最小的数值, 因为矩形切割为正方形肯定是以最小的边为边. 遍历时记录目前的最大值 max 并记录出现次数 total, 如果发现又出现更大的边, 则清空次数 total, 最后返回最大边出现次数 total","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode每日一题1414. 和为 K 的最少斐波那契数字数目","slug":"leetcode1414","date":"2022-02-03T08:58:45.000Z","updated":"2022-02-17T14:47:06.343Z","comments":true,"path":"2022/02/03/leetcode1414/","link":"","permalink":"https://interestingblog.top/2022/02/03/leetcode1414/","excerpt":"","text":"1234567891011121314151617181920212223class Solution &#123; public int findMinFibonacciNumbers(int k) &#123; List&lt;Integer&gt; fibList = new ArrayList&lt;&gt;(); fibList.add(1); fibList.add(1); int a = 1, b = 1; while (b &lt;= k) &#123; int c = a + b; a = b; b = c; fibList.add(c); &#125; int ans = 0; // 查找几个数组成k for (int i = fibList.size() - 1; i &gt;= 0; i--) &#123; if (fibList.get(i) &lt;= k) &#123; k -= fibList.get(i); ans++; &#125; &#125; return ans; &#125;&#125; 思路: 贪心算法先将数列创建出来, 然后假定有最优解, 从后向前遍历, 如果 数列的值 &lt;&#x3D; k, k &#x3D; k - 数列的值然后 ans 加一, 最后得出解为 ans.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://interestingblog.top/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://interestingblog.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"队列","slug":"队列","permalink":"https://interestingblog.top/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://interestingblog.top/tags/%E6%A0%88/"},{"name":"周赛","slug":"周赛","permalink":"https://interestingblog.top/tags/%E5%91%A8%E8%B5%9B/"},{"name":"贪心","slug":"贪心","permalink":"https://interestingblog.top/tags/%E8%B4%AA%E5%BF%83/"},{"name":"链表","slug":"链表","permalink":"https://interestingblog.top/tags/%E9%93%BE%E8%A1%A8/"},{"name":"遍历","slug":"遍历","permalink":"https://interestingblog.top/tags/%E9%81%8D%E5%8E%86/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://interestingblog.top/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"name":"动态规划","slug":"动态规划","permalink":"https://interestingblog.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://interestingblog.top/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"位运算","slug":"位运算","permalink":"https://interestingblog.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二分","slug":"二分","permalink":"https://interestingblog.top/tags/%E4%BA%8C%E5%88%86/"},{"name":"hash","slug":"hash","permalink":"https://interestingblog.top/tags/hash/"}]}